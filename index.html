<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>智能去水印工具 - Telea Inpainting Algorithm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            touch-action: manipulation;
            overscroll-behavior: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 16px;
            -webkit-user-select: none;
            user-select: none;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            padding: 20px 0;
            margin-bottom: 20px;
        }

        header h1 {
            font-size: clamp(1.5em, 5vw, 2.5em);
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: clamp(0.9em, 2.5vw, 1.1em);
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }

        @media (min-width: 900px) {
            .main-content {
                grid-template-columns: 280px 1fr;
            }
        }

        .sidebar {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .sidebar h2 {
            color: #333;
            margin-bottom: 16px;
            font-size: 1.1em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 16px;
            background: #fafbfc;
        }

        .upload-area:hover, .upload-area:active {
            background: #f0f4ff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .upload-area svg {
            width: 40px;
            height: 40px;
            fill: #667eea;
            margin-bottom: 8px;
        }

        .upload-area p {
            color: #666;
            font-size: 0.9em;
        }

        .upload-area small {
            color: #999;
            font-size: 0.75em;
        }

        .controls {
            margin-bottom: 16px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
        }

        .tool-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .tool-option {
            padding: 12px 8px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #fafbfc;
        }

        .tool-option:hover {
            border-color: #667eea;
        }

        .tool-option.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea15, #764ba215);
        }

        .tool-option svg {
            width: 24px;
            height: 24px;
            fill: #667eea;
            margin-bottom: 4px;
        }

        .tool-option span {
            display: block;
            font-size: 0.75em;
            color: #666;
            font-weight: 500;
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 10px;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .workspace {
            background: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            overflow-x: auto;
            padding-bottom: 4px;
        }

        .tab {
            padding: 10px 16px;
            border: none;
            background: #f0f2f5;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9em;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        @media (min-width: 600px) {
            .canvas-container {
                grid-template-columns: 1fr 1fr;
            }
        }

        .canvas-wrapper {
            position: relative;
        }

        .canvas-wrapper h3 {
            text-align: center;
            margin-bottom: 8px;
            color: #333;
            font-size: 0.9em;
        }

        canvas {
            width: 100%;
            height: auto;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: #f5f5f5;
            touch-action: none;
        }

        .canvas-wrapper.active-mask canvas {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .processing-info {
            background: linear-gradient(135deg, #667eea10, #764ba210);
            padding: 16px;
            border-radius: 12px;
            margin-top: 16px;
        }

        .processing-info h3 {
            font-size: 0.9em;
            color: #333;
            margin-bottom: 12px;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
            transition: all 0.3s;
        }

        .status-indicator.active {
            background: #667eea;
            animation: pulse 1s infinite;
        }

        .status-indicator.success {
            background: #10b981;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.8; }
        }

        .processing-info p {
            margin: 6px 0;
            color: #666;
            font-size: 0.85em;
        }

        .processing-info strong {
            color: #333;
        }

        .instructions {
            background: linear-gradient(135deg, #fff3cd, #ffeeba);
            padding: 14px;
            border-radius: 10px;
            margin-bottom: 16px;
            border-left: 4px solid #ffc107;
        }

        .instructions h4 {
            margin-bottom: 8px;
            color: #856404;
            font-size: 0.9em;
        }

        .instructions ul {
            margin-left: 16px;
            color: #856404;
            font-size: 0.85em;
        }

        .instructions li {
            margin: 4px 0;
        }

        .mobile-hint {
            display: none;
            background: #e3f2fd;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 0.8em;
            color: #1976d2;
        }

        @media (max-width: 600px) {
            .mobile-hint {
                display: block;
            }
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 3px;
            transition: width 0.1s;
            width: 0%;
        }

        .algorithm-info {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.8em;
            color: #666;
        }

        .algorithm-info strong {
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>智能去水印工具</h1>
            <p>Telea Fast Marching Inpainting 算法</p>
        </header>

        <div class="main-content">
            <aside class="sidebar">
                <h2>上传图片</h2>
                <div class="upload-area" id="uploadArea">
                    <svg viewBox="0 0 24 24"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>
                    <p>点击或拖拽图片</p>
                    <small>支持 JPG, PNG, WebP</small>
                    <input type="file" id="fileInput" accept="image/*" style="display: none;">
                </div>

                <div class="algorithm-info">
                    <strong>算法：</strong>Telea Fast Marching Method<br>
                    基于图像梯度的智能修复算法
                </div>

                <div class="controls">
                    <div class="tool-options">
                        <div class="tool-option active" data-tool="brush">
                            <svg viewBox="0 0 24 24"><path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/></svg>
                            <span>涂抹</span>
                        </div>
                        <div class="tool-option" data-tool="eraser">
                            <svg viewBox="0 0 24 24"><path d="M15.14 3c-.51 0-1.02.2-1.41.59L2.59 14.73c-.78.78-.78 2.05 0 2.83L5.17 20.17c.78.78 2.05.78 2.83 0l11.14-11.14c.78-.78.78-2.05 0-2.83l-2.59-2.59C16.16 3.2 15.65 3 15.14 3zM5 19l-1.41-1.41L12 9.17l2.59 2.59L5 19z"/></svg>
                            <span>橡皮擦</span>
                        </div>
                        <div class="tool-option" data-tool="auto">
                            <svg viewBox="0 0 24 24"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9.5 12.5l2.5 3.01L14.5 12l4 5H5l4.5-4.5z"/></svg>
                            <span>自动</span>
                        </div>
                    </div>

                    <div class="control-group" id="brushSizeGroup">
                        <label>画笔大小: <span id="brushSizeValue">30</span></label>
                        <input type="range" id="brushSize" min="10" max="100" value="30">
                    </div>

                    <div class="control-group" id="sensitivityGroup" style="display: none;">
                        <label>敏感度: <span id="sensitivityValue">50</span></label>
                        <input type="range" id="sensitivity" min="10" max="90" value="50">
                    </div>
                </div>

                <button class="btn btn-primary" id="processBtn" disabled>
                    开始智能修复
                </button>
                <button class="btn btn-secondary" id="downloadBtn" disabled>
                    保存结果
                </button>
                <button class="btn btn-secondary" id="resetBtn">
                    重新开始
                </button>
            </aside>

            <main class="workspace">
                <div class="mobile-hint">
                    提示：使用手指在图片上涂抹选择要去除的水印区域
                </div>

                <div class="instructions" id="instructions">
                    <h4>使用说明</h4>
                    <ul id="instructionList">
                        <li>上传图片后在图片上涂抹选择水印区域</li>
                        <li>可使用橡皮擦修正选择区域</li>
                        <li>点击"开始智能修复"执行Telea算法</li>
                    </ul>
                </div>

                <div class="tabs">
                    <button class="tab active" data-tab="both">对比视图</button>
                    <button class="tab" data-tab="result">只看结果</button>
                </div>

                <div class="canvas-container" id="canvasContainer">
                    <div class="canvas-wrapper active-mask" id="originalWrapper">
                        <h3>原图 / 涂抹选择</h3>
                        <canvas id="originalCanvas"></canvas>
                    </div>
                    <div class="canvas-wrapper" id="resultWrapper">
                        <h3>修复结果</h3>
                        <canvas id="resultCanvas"></canvas>
                    </div>
                </div>

                <div class="processing-info">
                    <h3>处理状态</h3>
                    <div class="status">
                        <div class="status-indicator" id="statusIndicator"></div>
                        <span id="statusText">准备就绪</span>
                    </div>
                    <p>图片尺寸: <strong id="imageSize">-</strong></p>
                    <p>修复耗时: <strong id="processTime">-</strong></p>
                    <p>已选择像素: <strong id="selectedPixels">0</strong></p>
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-bar-fill" id="progressFill"></div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        class TeleaInpainter {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.levelSet = new Float32Array(width * height);
                this.confidence = new Float32Array(width * height);
                this.data = new Float32Array(width * height);
                this.isMask = new Uint8Array(width * height);
                this.visited = new Uint8Array(width * height);
                
                this.initialize();
            }

            initialize() {
                for (let i = 0; i < this.width * this.height; i++) {
                    this.levelSet[i] = Infinity;
                    this.confidence[i] = 1.0;
                    this.visited[i] = 0;
                }
            }

            setMask(maskData) {
                for (let i = 0; i < maskData.length; i++) {
                    this.isMask[i] = maskData[i] > 127 ? 1 : 0;
                    if (this.isMask[i]) {
                        this.levelSet[i] = 0;
                    }
                }
            }

            computeGradient(data, x, y) {
                const w = this.width;
                const h = this.height;
                
                const getPixel = (px, py) => {
                    px = Math.max(0, Math.min(w - 1, px));
                    py = Math.max(0, Math.min(h - 1, py));
                    const idx = (py * w + px) * 4;
                    return [(data[idx]), (data[idx + 1]), (data[idx + 2])];
                };

                const p = getPixel(x, y);
                const left = getPixel(x - 1, y);
                const right = getPixel(x + 1, y);
                const up = getPixel(x, y - 1);
                const down = getPixel(x, y + 1);

                const gx = [
                    (right[0] - left[0]) / 2,
                    (right[1] - left[1]) / 2,
                    (right[2] - left[2]) / 2
                ];
                
                const gy = [
                    (down[0] - up[0]) / 2,
                    (down[1] - up[1]) / 2,
                    (down[2] - up[2]) / 2
                ];

                const gradientMag = Math.sqrt(gx[0]*gx[0] + gx[1]*gx[1] + gx[2]*gx[2] +
                                              gy[0]*gy[0] + gy[1]*gy[1] + gy[2]*gy[2] + 1e-6);
                
                return { gx, gy, magnitude: gradientMag };
            }

            computeDataTerm(data, x, y) {
                const grad = this.computeGradient(data, x, y);
                const normalizedGradX = { x: grad.gx[0] / (grad.magnitude + 1), y: grad.gx[1] / (grad.magnitude + 1), z: grad.gx[2] / (grad.magnitude + 1) };
                const normalizedGradY = { x: grad.gy[0] / (grad.magnitude + 1), y: grad.gy[1] / (grad.magnitude + 1), z: grad.gy[2] / (grad.magnitude + 1) };

                const laplacianX = data[((y) * this.width + (x + 1)) * 4] - 2 * data[(y * this.width + x) * 4] + data[((y) * this.width + (x - 1)) * 4];
                const laplacianY = data[((y + 1) * this.width + (x)) * 4] - 2 * data[(y * this.width + x) * 4] + data[((y - 1) * this.width + (x)) * 4];

                return normalizedGradX.x * laplacianX + normalizedGradY.x * laplacianY +
                       normalizedGradY.y * laplacianY + normalizedGradY.z * laplacianY;
            }

            inpaint(imageData, progressCallback) {
                const data = new Uint8ClampedArray(imageData.data);
                const w = this.width;
                const h = this.height;
                const totalPixels = w * h;
                let processed = 0;

                const priorityQueue = [];
                const inQueue = new Uint8Array(totalPixels);

                const pushToQueue = (x, y) => {
                    if (x < 0 || x >= w || y < 0 || y >= h) return;
                    const idx = y * w + x;
                    if (this.isMask[idx] || inQueue[idx]) return;
                    
                    let level = Infinity;
                    const neighbors = [
                        [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                    ];
                    
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            const nidx = ny * w + nx;
                            if (!this.isMask[nidx]) {
                                level = Math.min(level, this.levelSet[nidx]);
                            }
                        }
                    }
                    
                    this.levelSet[idx] = level + 1;
                    priorityQueue.push({x, y, level});
                    inQueue[idx] = 1;
                    priorityQueue.sort((a, b) => a.level - b.level);
                };

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = y * w + x;
                        if (this.isMask[idx]) {
                            const neighbors = [
                                [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                            ];
                            for (const [nx, ny] of neighbors) {
                                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                    const nidx = ny * w + nx;
                                    if (!this.isMask[nidx]) {
                                        pushToQueue(nx, ny);
                                    }
                                }
                            }
                        }
                    }
                }

                while (priorityQueue.length > 0) {
                    const {x, y} = priorityQueue.shift();
                    const idx = y * w + x;
                    
                    if (this.isMask[idx] || this.visited[idx]) continue;
                    this.visited[idx] = 1;
                    
                    const confidence = this.computeConfidence(x, y);
                    const dataTerm = this.computeDataTerm(data, x, y);
                    
                    this.fillPixel(data, x, y, confidence, dataTerm);
                    this.isMask[idx] = 1;
                    
                    processed++;
                    if (processed % 100 === 0 && progressCallback) {
                        progressCallback(processed / totalPixels);
                    }

                    const neighbors = [
                        [x-1, y], [x+1, y], [x, y-1], [x, y+1],
                        [x-1, y-1], [x+1, y-1], [x-1, y+1], [x+1, y+1]
                    ];
                    
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            const nidx = ny * w + nx;
                            if (!this.isMask[nidx]) {
                                pushToQueue(nx, ny);
                            }
                        }
                    }
                }

                return new ImageData(data, w, h);
            }

            computeConfidence(x, y) {
                const w = this.width;
                const h = this.height;
                let sumConfidence = 0;
                let count = 0;
                
                const patchSize = 3;
                for (let dy = -patchSize; dy <= patchSize; dy++) {
                    for (let dx = -patchSize; dx <= patchSize; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            const nidx = ny * w + nx;
                            if (!this.isMask[nidx]) {
                                sumConfidence += this.confidence[nidx];
                                count++;
                            }
                        }
                    }
                }
                
                return count > 0 ? sumConfidence / count : 0;
            }

            fillPixel(data, x, y, confidence, dataTerm) {
                const w = this.width;
                const h = this.height;
                const idx = y * w + x;
                
                let sumR = 0, sumG = 0, sumB = 0;
                let totalWeight = 0;
                
                const patchSize = 2;
                for (let dy = -patchSize; dy <= patchSize; dy++) {
                    for (let dx = -patchSize; dx <= patchSize; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                            const nidx = ny * w + nx;
                            if (!this.isMask[nidx]) {
                                const pixelIdx = nidx * 4;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const weight = 1 / (dist + 1);
                                sumR += data[pixelIdx] * weight;
                                sumG += data[pixelIdx + 1] * weight;
                                sumB += data[pixelIdx + 2] * weight;
                                totalWeight += weight;
                            }
                        }
                    }
                }
                
                if (totalWeight > 0) {
                    const targetIdx = idx * 4;
                    data[targetIdx] = sumR / totalWeight;
                    data[targetIdx + 1] = sumG / totalWeight;
                    data[targetIdx + 2] = sumB / totalWeight;
                }
                
                this.confidence[idx] = confidence;
            }
        }

        class WatermarkRemover {
            constructor() {
                this.originalImage = null;
                this.maskCanvas = null;
                this.maskCtx = null;
                this.currentTool = 'brush';
                this.brushSize = 30;
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.selectedPixels = 0;

                this.initElements();
                this.bindEvents();
            }

            initElements() {
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.originalCanvas = document.getElementById('originalCanvas');
                this.resultCanvas = document.getElementById('resultCanvas');
                this.originalCtx = this.originalCanvas.getContext('2d');
                this.resultCtx = this.resultCanvas.getContext('2d');
                this.processBtn = document.getElementById('processBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.brushSizeSlider = document.getElementById('brushSize');
                this.sensitivitySlider = document.getElementById('sensitivity');
                this.progressBar = document.getElementById('progressBar');
                this.progressFill = document.getElementById('progressFill');
            }

            bindEvents() {
                this.uploadArea.addEventListener('click', () => this.fileInput.click());
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.style.background = '#f0f4ff';
                });
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.style.background = '';
                });
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.style.background = '';
                    if (e.dataTransfer.files[0]) this.loadImage(e.dataTransfer.files[0]);
                });
                this.fileInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) this.loadImage(e.target.files[0]);
                });

                document.querySelectorAll('.tool-option').forEach(option => {
                    option.addEventListener('click', () => this.selectTool(option.dataset.tool));
                });

                this.brushSizeSlider.addEventListener('input', (e) => {
                    this.brushSize = parseInt(e.target.value);
                    document.getElementById('brushSizeValue').textContent = this.brushSize;
                });

                this.sensitivitySlider.addEventListener('input', (e) => {
                    document.getElementById('sensitivityValue').textContent = e.target.value;
                });

                this.processBtn.addEventListener('click', () => this.processImage());
                this.downloadBtn.addEventListener('click', () => this.downloadResult());
                this.resetBtn.addEventListener('click', () => this.reset());

                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                this.bindCanvasEvents();
            }

            bindCanvasEvents() {
                const events = {
                    'mousedown': 'startDrawing',
                    'mousemove': 'draw',
                    'mouseup': 'stopDrawing',
                    'mouseleave': 'stopDrawing',
                    'touchstart': 'handleTouchStart',
                    'touchmove': 'handleTouchMove',
                    'touchend': 'stopDrawing'
                };

                for (const [event, handler] of Object.entries(events)) {
                    this.originalCanvas.addEventListener(event, (e) => {
                        e.preventDefault();
                        this[handler](e);
                    });
                }
            }

            getCanvasCoords(e) {
                const rect = this.originalCanvas.getBoundingClientRect();
                const scaleX = this.originalCanvas.width / rect.width;
                const scaleY = this.originalCanvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            handleTouchStart(e) {
                this.startDrawing(e);
            }

            handleTouchMove(e) {
                this.draw(e);
            }

            startDrawing(e) {
                if (!this.originalImage) return;
                this.isDrawing = true;
                const coords = this.getCanvasCoords(e);
                this.lastX = coords.x;
                this.lastY = coords.y;
                this.drawOnMask(coords.x, coords.y);
            }

            draw(e) {
                if (!this.isDrawing) return;
                const coords = this.getCanvasCoords(e);
                
                this.drawOnMask(coords.x, coords.y);
                
                this.lastX = coords.x;
                this.lastY = coords.y;
            }

            drawOnMask(x, y) {
                if (!this.maskCtx) return;
                
                this.maskCtx.beginPath();
                if (this.currentTool === 'brush') {
                    this.maskCtx.globalCompositeOperation = 'source-over';
                    this.maskCtx.fillStyle = 'white';
                    this.maskCtx.strokeStyle = 'white';
                } else {
                    this.maskCtx.globalCompositeOperation = 'destination-out';
                }
                
                this.maskCtx.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);
                this.maskCtx.fill();
                
                this.updateSelectedCount();
                this.updatePreview();
            }

            stopDrawing() {
                this.isDrawing = false;
            }

            updateSelectedCount() {
                if (!this.maskCtx) return;
                const maskData = this.maskCtx.getImageData(0, 0, this.maskCanvas.width, this.maskCanvas.height);
                let count = 0;
                for (let i = 3; i < maskData.data.length; i += 4) {
                    if (maskData.data[i] > 0) count++;
                }
                this.selectedPixels = count;
                document.getElementById('selectedPixels').textContent = count.toLocaleString();
            }

            updatePreview() {
                if (!this.maskCtx || !this.originalCtx) return;
                this.originalCtx.drawImage(this.originalImage, 0, 0, this.originalCanvas.width, this.originalCanvas.height);
                this.originalCtx.globalAlpha = 0.3;
                this.originalCtx.drawImage(this.maskCanvas, 0, 0);
                this.originalCtx.globalAlpha = 1;
            }

            loadImage(file) {
                if (!file.type.startsWith('image/')) {
                    alert('请上传图片文件');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.setupCanvases(img);
                        this.processBtn.disabled = false;
                        this.updateImageInfo();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            setupCanvases(img) {
                const maxWidth = 800;
                const maxHeight = 600;
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = (maxWidth / width) * height;
                    width = maxWidth;
                }
                if (height > maxHeight) {
                    width = (maxHeight / height) * width;
                    height = maxHeight;
                }

                this.originalCanvas.width = width;
                this.originalCanvas.height = height;
                this.resultCanvas.width = width;
                this.resultCanvas.height = height;

                this.originalCtx.drawImage(img, 0, 0, width, height);

                this.maskCanvas = document.createElement('canvas');
                this.maskCanvas.width = width;
                this.maskCanvas.height = height;
                this.maskCtx = this.maskCanvas.getContext('2d');

                this.updatePreview();
            }

            updateImageInfo() {
                document.getElementById('imageSize').textContent = 
                    `${this.originalCanvas.width} × ${this.originalCanvas.height}`;
            }

            selectTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-option').forEach(opt => {
                    opt.classList.toggle('active', opt.dataset.tool === tool);
                });

                const brushGroup = document.getElementById('brushSizeGroup');
                const sensitivityGroup = document.getElementById('sensitivityGroup');
                const instructions = document.getElementById('instructionList');

                if (tool === 'brush') {
                    brushGroup.style.display = 'block';
                    sensitivityGroup.style.display = 'none';
                    instructions.innerHTML = `
                        <li>在图片上涂抹选择要去除的水印区域</li>
                        <li>可调整画笔大小以适应不同尺寸的水印</li>
                        <li>点击"开始智能修复"执行算法</li>
                    `;
                } else if (tool === 'eraser') {
                    brushGroup.style.display = 'block';
                    sensitivityGroup.style.display = 'none';
                    instructions.innerHTML = `
                        <li>擦除已选择的区域</li>
                        <li>修正涂抹错误的选择</li>
                    `;
                } else {
                    brushGroup.style.display = 'none';
                    sensitivityGroup.style.display = 'block';
                    instructions.innerHTML = `
                        <li>自动检测高亮/低暗区域作为水印</li>
                        <li>调整敏感度控制检测范围</li>
                        <li>点击"开始智能修复"</li>
                    `;
                }
            }

            async processImage() {
                if (this.selectedPixels < 10) {
                    alert('请先在图片上涂抹选择要去除的水印区域');
                    return;
                }

                this.updateStatus('正在初始化 Telea 算法...', true);
                this.progressBar.classList.add('active');

                await new Promise(r => setTimeout(r, 50));

                try {
                    const imageData = this.originalCtx.getImageData(
                        0, 0, this.originalCanvas.width, this.originalCanvas.height
                    );

                    let maskData;
                    if (this.currentTool === 'auto') {
                        maskData = this.autoDetectMask(imageData);
                    } else {
                        const maskImageData = this.maskCtx.getImageData(
                            0, 0, this.maskCanvas.width, this.maskCanvas.height
                        );
                        maskData = maskImageData.data;
                    }

                    const inpainter = new TeleaInpainter(
                        this.originalCanvas.width, 
                        this.originalCanvas.height
                    );
                    inpainter.setMask(maskData);

                    this.updateStatus('正在执行 Fast Marching...', true);

                    const result = await new Promise((resolve) => {
                        setTimeout(() => {
                            const result = inpainter.inpaint(imageData, (progress) => {
                                const percent = Math.round(progress * 100);
                                this.progressFill.style.width = percent + '%';
                                this.updateStatus(`正在修复 ${percent}%`, true);
                            });
                            resolve(result);
                        }, 100);
                    });

                    this.resultCtx.putImageData(result, 0, 0);

                    document.getElementById('processTime').textContent = '已完成';
                    this.updateStatus('修复完成 ✓', false);
                    this.progressBar.classList.remove('active');
                    this.downloadBtn.disabled = false;

                } catch (error) {
                    console.error('处理失败:', error);
                    this.updateStatus('处理失败', false);
                    this.progressBar.classList.remove('active');
                }
            }

            autoDetectMask(imageData) {
                const sensitivity = parseInt(this.sensitivitySlider.value) / 100;
                const threshold = 255 * sensitivity;
                const maskData = new Uint8ClampedArray(imageData.width * imageData.height * 4);

                for (let i = 0; i < imageData.data.length; i += 4) {
                    const brightness = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    if (brightness > 230 || brightness < 25) {
                        maskData[i] = 255;
                        maskData[i+1] = 255;
                        maskData[i+2] = 255;
                        maskData[i+3] = 255;
                    }
                }

                return maskData;
            }

            updateStatus(text, isActive) {
                document.getElementById('statusText').textContent = text;
                const indicator = document.getElementById('statusIndicator');
                indicator.classList.toggle('active', isActive);
                indicator.classList.remove('success');
                if (text.includes('完成')) {
                    indicator.classList.add('success');
                    indicator.classList.remove('active');
                }
            }

            switchTab(tab) {
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tab === tab);
                });

                const container = document.getElementById('canvasContainer');
                const originalWrapper = document.getElementById('originalWrapper');
                const resultWrapper = document.getElementById('resultWrapper');

                if (tab === 'result') {
                    container.style.gridTemplateColumns = '1fr';
                    originalWrapper.style.display = 'none';
                    resultWrapper.style.display = 'block';
                } else {
                    container.style.gridTemplateColumns = '1fr 1fr';
                    originalWrapper.style.display = 'block';
                    resultWrapper.style.display = 'block';
                }
            }

            downloadResult() {
                const link = document.createElement('a');
                link.download = 'watermark_removed_' + Date.now() + '.png';
                link.href = this.resultCanvas.toDataURL('image/png');
                link.click();
            }

            reset() {
                this.originalImage = null;
                this.selectedPixels = 0;
                
                this.originalCtx.clearRect(0, 0, this.originalCanvas.width, this.originalCanvas.height);
                this.resultCtx.clearRect(0, 0, this.resultCanvas.width, this.resultCanvas.height);
                
                this.processBtn.disabled = true;
                this.downloadBtn.disabled = true;
                
                document.getElementById('imageSize').textContent = '-';
                document.getElementById('processTime').textContent = '-';
                document.getElementById('selectedPixels').textContent = '0';
                document.getElementById('statusText').textContent = '准备就绪';
                document.getElementById('statusIndicator').classList.remove('active', 'success');
                this.progressBar.classList.remove('active');
            }
        }

        const remover = new WatermarkRemover();
    </script>
</body>
</html>
